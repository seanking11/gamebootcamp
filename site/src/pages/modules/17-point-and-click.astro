---
import BaseLayout from '../../layouts/BaseLayout.astro';
const base = import.meta.env.BASE_URL;
---

<BaseLayout title="Module 17: Point-and-Click Adventure">
  <div class="container page-content">
    <div class="module-header">
      <div class="module-number">Module 17</div>
      <h1>Point-and-Click Adventure</h1>
      <p class="module-theme">Puzzle-solving through object interaction and conversation &mdash; every item is a question; every combination is an answer.</p>
    </div>

    <blockquote>"I'm selling these fine leather jackets."</blockquote>

    <hr />

    <h2>Prerequisites</h2>
    <table>
      <thead>
        <tr><th>Module</th><th>What You Used From It</th></tr>
      </thead>
      <tbody>
        <tr><td>Module 01 - Pong</td><td>Basic game loop, rendering, and state management. Point-and-click adventures are mechanically simple but architecturally demanding.</td></tr>
      </tbody>
    </table>

    <hr />

    <h2>Week 1: History &amp; Design Theory</h2>

    <h3>The Origin</h3>
    <p><em>The Secret of Monkey Island</em> (1990), designed by Ron Gilbert and Tim Schafer at LucasArts, perfected the point-and-click adventure formula by solving the genre's greatest problem: unfair death. Sierra On-Line's earlier adventures (<em>King's Quest</em>, 1984) punished players with frequent, often unpredictable deaths and dead-end states where the game became unwinnable without the player knowing. Gilbert's philosophy, codified in his "Why Adventure Games Suck" manifesto, insisted that the player should never die and should never be able to reach a dead end. <em>Monkey Island</em> implemented this by designing every puzzle as a contained logical problem with discoverable solutions, using humor to make failed attempts entertaining rather than punishing, and building an inventory-combination system where the fun was in experimentation. The SCUMM engine (Script Creation Utility for Maniac Mansion) gave designers a verb-based interaction system &mdash; Look At, Pick Up, Use, Talk To &mdash; that made every screen a dense web of discoverable interactions.</p>

    <h3>How the Genre Evolved</h3>
    <p><strong>Myst (1993):</strong> Cyan Worlds' Rand and Robyn Miller stripped away the verb interface, inventory, and dialogue entirely, replacing them with environmental puzzles embedded in hauntingly beautiful pre-rendered worlds. Players clicked to move between static viewpoints and manipulated mechanisms directly. <em>Myst</em> proved that point-and-click adventure did not require inventory or conversation &mdash; pure environmental observation and logical deduction could sustain an entire game.</p>

    <p><strong>Disco Elysium (2019):</strong> ZA/UM's masterwork reimagined the adventure game through the lens of a tabletop RPG. Instead of combining physical objects, the player combined <em>ideas</em> in an internalized "thought cabinet." Every conversation was a potential puzzle, with 24 distinct skills functioning as inner voices that provided clues, opinions, and sometimes unreliable advice. It demonstrated that the core loop of point-and-click &mdash; observe, gather information, combine knowledge to progress &mdash; could be applied to dialogue and character psychology rather than physical inventory puzzles.</p>

    <h3>What Makes Point-and-Click "Great"</h3>
    <p>The core design insight of the point-and-click adventure is <strong>lateral thinking as gameplay</strong>. The genre asks the player to look at the world not as it is but as it <em>could be</em> &mdash; a rubber chicken is not just a rubber chicken but a potential tool when combined with a pulley. This trains a specific cognitive skill: the ability to hold multiple unrelated objects in mind and ask "what if these go together?" The best adventure games design puzzles where the solution, once discovered, feels obvious in retrospect ("of <em>course</em> you use the monkey as a wrench") &mdash; this retrospective clarity is the "aha!" moment that drives the entire genre.</p>

    <h3>The Essential Mechanic</h3>
    <p><strong>Combining found objects and information to solve environmental puzzles</strong> &mdash; the player observes, collects, reasons about connections, and applies items or knowledge to overcome obstacles.</p>

    <hr />

    <h2>Week 2: Build the MVP</h2>

    <h3>What You're Building</h3>
    <p>A 3-5 room adventure game with an inventory system, at least one item-combination puzzle, a dialog tree with a single NPC, and a puzzle dependency chain where solving one puzzle unlocks the next. The player clicks to interact with hotspots, collects items, and combines them to progress.</p>
    <p>This module is 2D. No engine is required.</p>

    <h3>Core Concepts (Must Implement)</h3>

    <h4>1. Inventory System with Item Combination</h4>
    <p>The player carries a collection of items represented as objects with properties (name, description, icon, use-cases). Items can be used on hotspots in the world or combined with each other in the inventory to produce new items.</p>
    <pre is:raw><code>class Item:
    def __init__(self, id, name, description, icon):
        self.id = id
        self.name = name
        self.description = description
        self.icon = icon

class Inventory:
    def __init__(self):
        self.items = {}  # id -> Item

    def add(self, item):
        self.items[item.id] = item

    def remove(self, item_id):
        del self.items[item_id]

    def has(self, item_id):
        return item_id in self.items

    def try_combine(self, item_a_id, item_b_id):
        key = frozenset([item_a_id, item_b_id])
        if key in COMBINATION_RECIPES:
            result = COMBINATION_RECIPES[key]
            self.remove(item_a_id)
            self.remove(item_b_id)
            self.add(result)
            return result
        return None

COMBINATION_RECIPES = {
    frozenset(["rope", "hook"]): Item("grapple", "Grappling Hook",
        "A hook tied to a rope. Could reach high places.", "grapple.png"),
    frozenset(["key_half_a", "key_half_b"]): Item("full_key", "Complete Key",
        "Both halves joined together.", "full_key.png"),
}</code></pre>
    <p><strong>Why it matters:</strong> The inventory is the player's toolkit. Every puzzle in the game is ultimately solved by having the right item and applying it in the right place. The combination system multiplies puzzle possibilities exponentially &mdash; N items yield N*(N-1)/2 potential combinations.</p>

    <!-- Demo 1: Inventory Combination Puzzle -->
    <div class="demo-container">
      <div class="demo-label">Demo: Inventory Combination Puzzle</div>
      <p class="demo-hint">Click on highlighted objects in the scene to pick them up. Items appear in the inventory bar at the bottom. Click an inventory item to select it (yellow border), then click another item to try combining them. Use combined items on the locked chest to solve the puzzle!</p>
      <canvas id="demo-inventory" width="760" height="500"></canvas>
    </div>

    <h4>2. Puzzle Dependency Graph</h4>
    <p>The game's puzzles form a directed acyclic graph (DAG) where each puzzle has prerequisites (items, flags, or other puzzles). Designing this graph up front ensures puzzles are solvable in a valid order and prevents dead ends.</p>
    <pre is:raw><code>puzzle_graph = {
    "get_rope": {
        requires: [],
        grants: ["rope"],
        description: "Pick up rope from the dock"
    },
    "talk_to_fisherman": {
        requires: [],
        grants: ["flag:fisherman_talked"],
        description: "Learn that the fisherman lost his hook"
    },
    "get_hook": {
        requires: ["flag:fisherman_talked"],
        grants: ["hook"],
        description: "Fisherman gives you his spare hook"
    },
    "make_grapple": {
        requires: ["rope", "hook"],
        grants: ["grapple"],
        description: "Combine rope + hook = grappling hook"
    },
    "climb_tower": {
        requires: ["grapple"],
        grants: ["flag:reached_tower_top"],
        description: "Use grappling hook to reach the tower top"
    },
    "open_gate": {
        requires: ["key"],
        grants: ["flag:game_complete"],
        description: "Use key on the locked gate â€” victory!"
    }
}</code></pre>
    <p><strong>Why it matters:</strong> The puzzle dependency graph is the game's blueprint. Without it, designers risk creating unsolvable states, circular dependencies, or puzzles where the player has no idea what to do next.</p>

    <h4>3. Dialog Trees</h4>
    <p>Conversations with NPCs are represented as a graph of dialog nodes. Each node contains NPC text and a list of player response options. Selecting a response may lead to another dialog node, set a game state flag, give the player an item, or end the conversation.</p>
    <pre is:raw><code>dialog_fisherman = {
    "start": {
        npc_text: "Ahoy! I'd be fishing, but I lost my best hook overboard.",
        options: [
            { text: "That's too bad.", next: "sympathy" },
            { text: "Do you have a spare?", next: "spare_hook" },
            { text: "Goodbye.", next: null }
        ]
    },
    "sympathy": {
        npc_text: "Aye, it's been a rough week. Say, you look resourceful...",
        options: [
            { text: "Do you have a spare hook?", next: "spare_hook" },
            { text: "I should go.", next: null }
        ]
    },
    "spare_hook": {
        npc_text: "Matter of fact, I do. Here, take it.",
        options: [
            { text: "Thanks!", next: null }
        ],
        on_enter: [
            { action: "give_item", item: "hook" },
            { action: "set_flag", flag: "fisherman_talked", value: true }
        ]
    }
}</code></pre>
    <p><strong>Why it matters:</strong> Dialog is the primary way adventure games deliver narrative, character, and puzzle clues. The tree structure lets designers create conversations that feel responsive to the player's curiosity while ensuring that essential information is always reachable.</p>

    <!-- Demo 2: Dialog Tree -->
    <div class="demo-container">
      <div class="demo-label">Demo: Branching Dialog Tree</div>
      <p class="demo-hint">Click on dialog options to navigate the conversation. The graph on the right updates in real-time showing which nodes you have visited (green), your current node (yellow), and unvisited nodes (gray). Flags set by the conversation appear at the bottom. Choices can unlock or lock future options!</p>
      <canvas id="demo-dialog" width="760" height="480"></canvas>
    </div>

    <h4>4. Hotspot Interaction System</h4>
    <p>Each scene contains clickable hotspots &mdash; regions of the screen that the player can interact with. Hotspots have a position, a bounding area, and responses for different interaction types (look, use, use-item-on). The cursor changes to indicate when it is over a hotspot.</p>
    <pre is:raw><code>class Hotspot:
    def __init__(self, id, name, bounds, interactions):
        self.id = id
        self.name = name
        self.bounds = bounds          # {x, y, width, height}
        self.interactions = interactions
        self.active = true

    def contains(self, mouse_x, mouse_y):
        b = self.bounds
        return (b.x &lt;= mouse_x &lt;= b.x + b.width and
                b.y &lt;= mouse_y &lt;= b.y + b.height)

def handle_click(mouse_x, mouse_y, current_scene, selected_item):
    for hotspot in current_scene.hotspots:
        if not hotspot.active or not hotspot.contains(mouse_x, mouse_y):
            continue
        if selected_item:
            use_item = hotspot.interactions.get("use_item", {})
            response = use_item.get(selected_item.id, use_item.get("default"))
        else:
            response = hotspot.interactions.get("look")
        execute_response(response)
        return
    deselect_item()</code></pre>
    <p><strong>Why it matters:</strong> Hotspots are the player's primary interface with the game world. They transform a static background image into an interactive space. The cursor feedback is critical &mdash; the player must be able to discover what is interactive without clicking blindly on every pixel.</p>

    <h4>5. Scene / Room Management</h4>
    <p>The game is organized into discrete scenes (rooms), each with its own background image, hotspots, NPCs, and entry/exit points. A scene manager handles loading scenes, running transitions between them, and maintaining per-scene state.</p>
    <pre is:raw><code>class SceneManager:
    def __init__(self):
        self.scenes = {}
        self.current_scene = null
        self.transition_state = "none"
        self.fade_alpha = 0.0

    def change_scene(self, target_id):
        self.transition_state = "fading_out"
        self.next_scene_id = target_id

    def update(self, dt):
        if self.transition_state == "fading_out":
            self.fade_alpha += dt * FADE_SPEED
            if self.fade_alpha >= 1.0:
                self.current_scene = self.scenes[self.next_scene_id]
                self.transition_state = "fading_in"
        elif self.transition_state == "fading_in":
            self.fade_alpha -= dt * FADE_SPEED
            if self.fade_alpha &lt;= 0.0:
                self.fade_alpha = 0.0
                self.transition_state = "none"</code></pre>
    <p><strong>Why it matters:</strong> Scene management is the architecture that holds the entire game together. Clean scene management makes the game trivially extensible &mdash; adding a new room means defining a new data object, not modifying core logic.</p>

    <h4>6. Game State Flags</h4>
    <p>A centralized flag system tracks everything the player has done, seen, and said. Flags are boolean or string values keyed by name. Hotspots, dialog options, and puzzle logic all read from and write to this shared state.</p>
    <pre is:raw><code>class GameStateFlags:
    def __init__(self):
        self.flags = {}

    def set_flag(self, name, value=true):
        self.flags[name] = value

    def get_flag(self, name, default=false):
        return self.flags.get(name, default)

    def check_condition(self, condition):
        if " AND " in condition:
            parts = condition.split(" AND ")
            return all(self.check_condition(p.strip()) for p in parts)
        if " OR " in condition:
            parts = condition.split(" OR ")
            return any(self.check_condition(p.strip()) for p in parts)
        if condition.startswith("!"):
            return not self.check_flag(condition[1:])
        return self.check_flag(condition)</code></pre>
    <p><strong>Why it matters:</strong> Flags are the memory of the game world. They are how the game tracks cause and effect across rooms, conversations, and time. Without a centralized flag system, tracking what the player has done becomes a tangled mess of ad-hoc variables.</p>

    <hr />

    <h3>Stretch Goals</h3>
    <ul>
      <li><strong>Character walking:</strong> The player character walks to the clicked hotspot before interacting, with simple pathfinding around obstacles.</li>
      <li><strong>Verb interface:</strong> Add a classic verb bar (Look At, Pick Up, Use, Talk To) where the player selects a verb before clicking a hotspot.</li>
      <li><strong>Conditional dialog options:</strong> Dialog options that only appear when certain flags are set.</li>
      <li><strong>Hint system:</strong> A progressive hint system that provides increasingly specific clues when the player is stuck.</li>
    </ul>

    <h3>MVP Spec</h3>
    <table>
      <thead><tr><th>Feature</th><th>Required</th></tr></thead>
      <tbody>
        <tr><td>3-5 scenes with background images</td><td>Yes</td></tr>
        <tr><td>Clickable hotspots with look/use responses</td><td>Yes</td></tr>
        <tr><td>Inventory UI with item collection</td><td>Yes</td></tr>
        <tr><td>At least one item combination puzzle</td><td>Yes</td></tr>
        <tr><td>Use-item-on-hotspot interaction</td><td>Yes</td></tr>
        <tr><td>At least one NPC with dialog tree</td><td>Yes</td></tr>
        <tr><td>Scene transitions (fade or cut)</td><td>Yes</td></tr>
        <tr><td>Game state flags driving conditional content</td><td>Yes</td></tr>
        <tr><td>Puzzle dependency chain of 4+ steps</td><td>Yes</td></tr>
        <tr><td>Context-sensitive cursor</td><td>Yes</td></tr>
        <tr><td>Character walking animation</td><td>Stretch</td></tr>
        <tr><td>Verb bar interface</td><td>Stretch</td></tr>
        <tr><td>Conditional dialog options</td><td>Stretch</td></tr>
        <tr><td>Hint system</td><td>Stretch</td></tr>
      </tbody>
    </table>

    <h3>Deliverable</h3>
    <p>Submit your playable adventure game with source code and a <strong>puzzle dependency graph diagram</strong> showing all puzzles as nodes, their prerequisites as edges, and the items/flags each puzzle grants. Include a short write-up (300-500 words) answering: <em>How did you design your puzzle chain to be solvable without a walkthrough? What clues did you embed in dialog, item descriptions, and environmental details to guide the player toward solutions?</em></p>

    <hr />

    <h2>Analogies by Background</h2>
    <blockquote><p>These analogies map game dev concepts to patterns you already know.</p></blockquote>

    <h3>For Backend Developers</h3>
    <table>
      <thead><tr><th>Game Dev Concept</th><th>Backend Analogy</th></tr></thead>
      <tbody>
        <tr><td>Inventory with item combination</td><td>A key-value store with composite key lookups &mdash; items are values, combinations are queries against a recipe table, producing new entries</td></tr>
        <tr><td>Puzzle dependency graph</td><td>A task DAG (like Airflow or Makefile targets) &mdash; each task has prerequisites that must complete before it can execute</td></tr>
        <tr><td>Dialog trees</td><td>A state machine for request handling &mdash; each state presents a response and a set of valid transitions, with side effects triggered on state entry</td></tr>
        <tr><td>Hotspot interaction system</td><td>A URL router with method handling &mdash; each hotspot is a route, each interaction type is an HTTP method</td></tr>
        <tr><td>Scene / room management</td><td>Microservice orchestration &mdash; each scene is an independent service with its own state, and the scene manager is the API gateway</td></tr>
        <tr><td>Game state flags</td><td>A feature flag service (LaunchDarkly, etc.) &mdash; a centralized boolean store that all services query to determine behavior</td></tr>
      </tbody>
    </table>

    <h3>For Frontend Developers</h3>
    <table>
      <thead><tr><th>Game Dev Concept</th><th>Frontend Analogy</th></tr></thead>
      <tbody>
        <tr><td>Inventory with item combination</td><td>Shopping cart with bundle logic &mdash; items in the cart can be combined into bundles, producing a new line item</td></tr>
        <tr><td>Puzzle dependency graph</td><td>Component dependency tree &mdash; components (puzzles) can only render (solve) when their required props (items/flags) are provided</td></tr>
        <tr><td>Dialog trees</td><td>A multi-step wizard/form &mdash; each step shows content and options, the selected option determines the next step</td></tr>
        <tr><td>Hotspot interaction system</td><td>Event delegation on a composite UI &mdash; clickable regions within an image map, each with hover states and click handlers</td></tr>
        <tr><td>Scene / room management</td><td>Client-side routing &mdash; each scene is a route/page, the scene manager is the router</td></tr>
        <tr><td>Game state flags</td><td>Global application state (Redux/Zustand) &mdash; a centralized store that components subscribe to</td></tr>
      </tbody>
    </table>

    <h3>For Data / ML Engineers</h3>
    <table>
      <thead><tr><th>Game Dev Concept</th><th>Data / ML Analogy</th></tr></thead>
      <tbody>
        <tr><td>Inventory with item combination</td><td>Feature engineering &mdash; raw features (items) are combined through defined transformations (recipes) to produce derived features</td></tr>
        <tr><td>Puzzle dependency graph</td><td>A data pipeline DAG (Airflow, dbt) &mdash; each node is a transformation with defined inputs</td></tr>
        <tr><td>Dialog trees</td><td>A decision tree classifier &mdash; each node splits on a player choice, leaf nodes produce outcomes</td></tr>
        <tr><td>Hotspot interaction system</td><td>Labeled training data &mdash; each hotspot is an annotated region in an image with associated metadata</td></tr>
        <tr><td>Scene / room management</td><td>Dataset partitioning &mdash; each scene is a partition of the total game data, loaded independently</td></tr>
        <tr><td>Game state flags</td><td>Experiment tracking metadata &mdash; a centralized log of which experiments (actions) have been run</td></tr>
      </tbody>
    </table>

    <hr />

    <h3>Discussion Questions</h3>
    <ol>
      <li><strong>Fair puzzles vs. obscure puzzles:</strong> Classic adventure games were notorious for illogical puzzles (the "cat hair mustache" problem). How do you design puzzles that are challenging but fair? What is the role of the puzzle dependency graph in ensuring the player always has enough information?</li>
      <li><strong>The dead-end problem:</strong> Ron Gilbert's manifesto argued that adventure games should never create unwinnable states. How does your puzzle dependency graph guarantee this? Could a game intentionally use dead ends as a design tool?</li>
      <li><strong>Dialog as puzzle:</strong> In games like <em>Disco Elysium</em>, dialog itself is the puzzle. How does this differ from using dialog purely as a clue-delivery system?</li>
      <li><strong>The hint economy:</strong> When a player is stuck, they will either consult a walkthrough (leaving your game) or quit. How would you design an in-game hint system that helps stuck players without spoiling satisfaction?</li>
    </ol>

    <nav class="module-nav">
      <a href={`${base}modules/16-third-person-shooter/`}>&larr; Module 16: Third-Person Shooter</a>
      <a href={`${base}modules/18-visual-novel/`}>Module 18: Visual Novel &rarr;</a>
    </nav>
  </div>

  <script>
    // Demo 1: Inventory Combination Puzzle
    (function() {
      const canvas = document.getElementById('demo-inventory');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;

      const SCENE_H = 380;
      const INV_Y = SCENE_H + 5;
      const INV_H = H - SCENE_H - 5;
      const SLOT = 60;

      const inventory = [];
      let selected = null;
      let message = '';
      let messageTimer = 0;
      let solved = false;

      const sceneObjects = [
        { id: 'rope', name: 'Rope', x: 80, y: 200, w: 40, h: 50, color: '#aa8844', picked: false, icon: 'R', desc: 'A sturdy piece of rope.' },
        { id: 'hook', name: 'Hook', x: 620, y: 140, w: 35, h: 35, color: '#888899', picked: false, icon: 'H', desc: 'A metal hook.' },
        { id: 'gem', name: 'Red Gem', x: 350, y: 100, w: 30, h: 30, color: '#dd3344', picked: false, icon: 'G', desc: 'A glowing red gem.' },
      ];

      const combinations = {
        'rope+hook': { id: 'grapple', name: 'Grappling Hook', icon: 'GH', color: '#ccaa44', desc: 'Rope tied to hook. Can reach the high shelf!' },
        'hook+rope': { id: 'grapple', name: 'Grappling Hook', icon: 'GH', color: '#ccaa44', desc: 'Rope tied to hook. Can reach the high shelf!' },
      };

      const hotspots = [
        { id: 'shelf', name: 'High Shelf', x: 440, y: 40, w: 100, h: 30, needsItem: 'grapple', gives: 'key', giveName: 'Brass Key', giveIcon: 'K', giveColor: '#ddaa22', giveDesc: 'An old brass key.', usedMsg: 'You hook the shelf and pull down a key!', failMsg: 'The shelf is too high to reach.' },
        { id: 'chest', name: 'Locked Chest', x: 300, y: 260, w: 80, h: 60, needsItem: 'key', gives: null, usedMsg: 'The chest opens! You found the treasure!', failMsg: 'The chest is locked tight.' },
      ];

      function showMsg(m) { message = m; messageTimer = 180; }

      function findInvItem(id) { return inventory.find(function(i) { return i.id === id; }); }

      function draw() {
        // Scene background
        ctx.fillStyle = '#1a2233';
        ctx.fillRect(0, 0, W, SCENE_H);

        // Room walls
        ctx.fillStyle = '#2a3344';
        ctx.fillRect(20, 20, W - 40, SCENE_H - 40);
        ctx.strokeStyle = '#3a4455';
        ctx.lineWidth = 2;
        ctx.strokeRect(20, 20, W - 40, SCENE_H - 40);

        // Floor line
        ctx.strokeStyle = '#3a4455';
        ctx.beginPath();
        ctx.moveTo(20, 300);
        ctx.lineTo(W - 20, 300);
        ctx.stroke();

        // Hotspots (scene objects)
        for (const hs of hotspots) {
          if (hs.id === 'chest' && solved) {
            ctx.fillStyle = '#44aa44';
            ctx.fillRect(hs.x, hs.y, hs.w, hs.h);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px monospace';
            ctx.fillText('OPEN!', hs.x + 14, hs.y + 35);
          } else {
            ctx.fillStyle = hs.id === 'shelf' ? '#554433' : '#664422';
            ctx.fillRect(hs.x, hs.y, hs.w, hs.h);
            ctx.strokeStyle = '#887766';
            ctx.strokeRect(hs.x, hs.y, hs.w, hs.h);
            ctx.fillStyle = '#aaaaaa';
            ctx.font = '11px monospace';
            ctx.fillText(hs.name, hs.x + 4, hs.y + hs.h + 14);
          }
        }

        // Scene items (not yet picked up)
        for (const obj of sceneObjects) {
          if (obj.picked) continue;
          ctx.fillStyle = obj.color;
          ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
          ctx.strokeStyle = '#ffff88';
          ctx.lineWidth = 2;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(obj.x - 2, obj.y - 2, obj.w + 4, obj.h + 4);
          ctx.setLineDash([]);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 14px monospace';
          ctx.fillText(obj.icon, obj.x + 8, obj.y + obj.h / 2 + 5);
          ctx.fillStyle = '#cccccc';
          ctx.font = '10px monospace';
          ctx.fillText(obj.name, obj.x, obj.y - 5);
        }

        // Inventory bar
        ctx.fillStyle = '#0d1520';
        ctx.fillRect(0, INV_Y, W, INV_H);
        ctx.strokeStyle = '#334455';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, INV_Y, W, INV_H);

        ctx.fillStyle = '#667788';
        ctx.font = '12px monospace';
        ctx.fillText('Inventory (click item to select, click another to combine):', 10, INV_Y + 16);

        for (let i = 0; i < inventory.length; i++) {
          const item = inventory[i];
          const sx = 10 + i * (SLOT + 8);
          const sy = INV_Y + 24;
          ctx.fillStyle = item.color || '#555566';
          ctx.fillRect(sx, sy, SLOT, SLOT);
          if (selected === i) {
            ctx.strokeStyle = '#ffdd44';
            ctx.lineWidth = 3;
            ctx.strokeRect(sx - 2, sy - 2, SLOT + 4, SLOT + 4);
          } else {
            ctx.strokeStyle = '#556677';
            ctx.lineWidth = 1;
            ctx.strokeRect(sx, sy, SLOT, SLOT);
          }
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 16px monospace';
          ctx.fillText(item.icon, sx + 8, sy + 35);
          ctx.font = '9px monospace';
          ctx.fillText(item.name, sx + 2, sy + SLOT + 12);
        }

        // Message
        if (messageTimer > 0) {
          messageTimer--;
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(W / 2 - 200, SCENE_H - 50, 400, 35);
          ctx.fillStyle = '#ffdd88';
          ctx.font = '14px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(message, W / 2, SCENE_H - 28);
          ctx.textAlign = 'left';
        }
      }

      canvas.addEventListener('click', function(e) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (W / rect.width);
        const my = (e.clientY - rect.top) * (H / rect.height);

        // Click on scene items
        if (my < SCENE_H) {
          for (const obj of sceneObjects) {
            if (!obj.picked && mx >= obj.x && mx <= obj.x + obj.w && my >= obj.y && my <= obj.y + obj.h) {
              obj.picked = true;
              inventory.push({ id: obj.id, name: obj.name, icon: obj.icon, color: obj.color, desc: obj.desc });
              showMsg('Picked up: ' + obj.name);
              selected = null;
              draw();
              return;
            }
          }

          // Click on hotspots with selected item
          if (selected !== null) {
            for (const hs of hotspots) {
              if (mx >= hs.x && mx <= hs.x + hs.w && my >= hs.y && my <= hs.y + hs.h) {
                const item = inventory[selected];
                if (item && item.id === hs.needsItem) {
                  inventory.splice(selected, 1);
                  selected = null;
                  if (hs.gives) {
                    inventory.push({ id: hs.gives, name: hs.giveName, icon: hs.giveIcon, color: hs.giveColor, desc: hs.giveDesc });
                  }
                  if (hs.id === 'chest') solved = true;
                  showMsg(hs.usedMsg);
                } else {
                  showMsg(hs.failMsg);
                }
                draw();
                return;
              }
            }
          }

          // Click hotspots without item
          for (const hs of hotspots) {
            if (mx >= hs.x && mx <= hs.x + hs.w && my >= hs.y && my <= hs.y + hs.h) {
              showMsg(hs.failMsg);
              draw();
              return;
            }
          }

          selected = null;
          draw();
          return;
        }

        // Click on inventory
        if (my >= INV_Y + 24 && my <= INV_Y + 24 + SLOT) {
          for (let i = 0; i < inventory.length; i++) {
            const sx = 10 + i * (SLOT + 8);
            if (mx >= sx && mx <= sx + SLOT) {
              if (selected === null || selected === i) {
                selected = (selected === i) ? null : i;
              } else {
                // Try combine
                const a = inventory[selected];
                const b = inventory[i];
                const key = a.id + '+' + b.id;
                if (combinations[key]) {
                  const result = combinations[key];
                  const idxA = Math.max(selected, i);
                  const idxB = Math.min(selected, i);
                  inventory.splice(idxA, 1);
                  inventory.splice(idxB, 1);
                  inventory.push({ id: result.id, name: result.name, icon: result.icon, color: result.color, desc: result.desc });
                  showMsg('Combined! Created: ' + result.name);
                  selected = null;
                } else {
                  showMsg('Those items cannot be combined.');
                  selected = null;
                }
              }
              draw();
              return;
            }
          }
        }

        selected = null;
        draw();
      });

      draw();
    })();

    // Demo 2: Branching Dialog Tree
    (function() {
      const canvas = document.getElementById('demo-dialog');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;

      const DIALOG_W = 400;
      const GRAPH_X = 420;

      const flags = {};
      const visited = {};

      const dialog = {
        start: {
          speaker: 'Old Sage',
          text: 'Welcome, traveler. I sense you seek knowledge. What brings you to my tower?',
          options: [
            { text: 'I need to cross the Void Bridge.', next: 'bridge_q' },
            { text: 'I heard you have a magic amulet.', next: 'amulet_q' },
            { text: 'Just passing through.', next: 'passing' },
          ]
        },
        bridge_q: {
          speaker: 'Old Sage',
          text: 'The Void Bridge... only the brave or the foolish seek that path. You will need the Word of Crossing.',
          setFlag: 'knows_bridge',
          options: [
            { text: 'How do I learn the Word?', next: 'word_how' },
            { text: 'Tell me about the amulet instead.', next: 'amulet_q' },
            { text: 'Thank you. Goodbye.', next: null },
          ]
        },
        amulet_q: {
          speaker: 'Old Sage',
          text: 'My amulet? It was stolen by the Shadow Thief. I would reward anyone who returns it.',
          setFlag: 'knows_amulet',
          options: [
            { text: 'I will find it for you!', next: 'accept_quest', requireNot: 'quest_accepted' },
            { text: 'What about the Void Bridge?', next: 'bridge_q' },
            { text: 'That sounds dangerous. Goodbye.', next: null },
          ]
        },
        accept_quest: {
          speaker: 'Old Sage',
          text: 'Brave soul! The Shadow Thief lurks in the eastern caves. Return my amulet and I will teach you the Word of Crossing.',
          setFlag: 'quest_accepted',
          options: [
            { text: 'I will return with it. Farewell.', next: null },
            { text: 'Any tips for fighting the Thief?', next: 'tips', require: 'quest_accepted' },
          ]
        },
        tips: {
          speaker: 'Old Sage',
          text: 'The Shadow Thief fears light. Bring a torch and he cannot hide. Also... he is allergic to cats.',
          setFlag: 'has_tips',
          options: [
            { text: 'Allergic to cats? Really?', next: 'cats' },
            { text: 'Thanks for the advice!', next: null },
          ]
        },
        cats: {
          speaker: 'Old Sage',
          text: '(chuckles) I may have made that part up. But the torch part is true. Good luck, traveler!',
          options: [
            { text: '(Leave, slightly concerned)', next: null },
          ]
        },
        word_how: {
          speaker: 'Old Sage',
          text: 'The Word of Crossing can only be learned by one who has proven their worth. Return my stolen amulet, and I will teach it to you.',
          options: [
            { text: 'Where is the amulet?', next: 'amulet_q' },
            { text: 'I understand. Goodbye.', next: null },
          ]
        },
        passing: {
          speaker: 'Old Sage',
          text: 'Hmm, few come this high on the mountain just to "pass through." But as you wish. My door is open if you change your mind.',
          options: [
            { text: 'Actually, I need help with something...', next: 'start' },
            { text: 'Goodbye, old man.', next: null },
          ]
        },
      };

      // Graph layout positions
      const graphNodes = {
        start:        { x: 100, y: 30 },
        bridge_q:     { x: 30,  y: 100 },
        amulet_q:     { x: 100, y: 100 },
        passing:      { x: 180, y: 100 },
        word_how:     { x: 30,  y: 170 },
        accept_quest: { x: 100, y: 170 },
        tips:         { x: 100, y: 240 },
        cats:         { x: 100, y: 310 },
      };

      let currentNode = 'start';
      visited[currentNode] = true;
      if (dialog[currentNode].setFlag) flags[dialog[currentNode].setFlag] = true;

      function getActiveOptions(node) {
        if (!node.options) return [];
        return node.options.filter(function(opt) {
          if (opt.require && !flags[opt.require]) return false;
          if (opt.requireNot && flags[opt.requireNot]) return false;
          return true;
        });
      }

      function draw() {
        ctx.clearRect(0, 0, W, H);

        // Dialog panel background
        ctx.fillStyle = '#111822';
        ctx.fillRect(0, 0, DIALOG_W, H);

        // Graph panel
        ctx.fillStyle = '#0d1520';
        ctx.fillRect(GRAPH_X, 0, W - GRAPH_X, H);
        ctx.strokeStyle = '#2a3a4a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(GRAPH_X, 0);
        ctx.lineTo(GRAPH_X, H);
        ctx.stroke();

        if (currentNode === null) {
          // Conversation ended
          ctx.fillStyle = '#aabbcc';
          ctx.font = '16px monospace';
          ctx.fillText('Conversation ended.', 30, 60);
          ctx.fillStyle = '#667788';
          ctx.font = '13px monospace';
          ctx.fillText('Click anywhere to restart.', 30, 90);
        } else {
          const node = dialog[currentNode];
          const options = getActiveOptions(node);

          // Speaker
          ctx.fillStyle = '#ffdd88';
          ctx.font = 'bold 16px monospace';
          ctx.fillText(node.speaker, 20, 35);

          // NPC text with word wrap
          ctx.fillStyle = '#ccddee';
          ctx.font = '14px monospace';
          const words = node.text.split(' ');
          let line = '';
          let ty = 65;
          for (const word of words) {
            const test = line + word + ' ';
            if (ctx.measureText(test).width > DIALOG_W - 40) {
              ctx.fillText(line, 20, ty);
              line = word + ' ';
              ty += 20;
            } else {
              line = test;
            }
          }
          ctx.fillText(line, 20, ty);

          // Options
          const optY = ty + 50;
          ctx.fillStyle = '#667788';
          ctx.font = '12px monospace';
          ctx.fillText('Your response:', 20, optY - 10);

          for (let i = 0; i < options.length; i++) {
            const oy = optY + i * 40;
            ctx.fillStyle = '#1a2a3a';
            ctx.fillRect(20, oy, DIALOG_W - 40, 32);
            ctx.strokeStyle = '#3a5a7a';
            ctx.lineWidth = 1;
            ctx.strokeRect(20, oy, DIALOG_W - 40, 32);
            ctx.fillStyle = '#88bbee';
            ctx.font = '13px monospace';
            ctx.fillText((i + 1) + '. ' + options[i].text, 30, oy + 21);
          }
        }

        // Draw graph
        ctx.fillStyle = '#667788';
        ctx.font = 'bold 13px monospace';
        ctx.fillText('Dialog Graph', GRAPH_X + 15, 25);

        const gox = GRAPH_X + 30;
        const goy = 40;

        // Draw edges
        for (const [nodeId, nodeData] of Object.entries(dialog)) {
          if (!graphNodes[nodeId]) continue;
          const from = graphNodes[nodeId];
          if (!nodeData.options) continue;
          for (const opt of nodeData.options) {
            if (opt.next && graphNodes[opt.next]) {
              const to = graphNodes[opt.next];
              ctx.strokeStyle = (visited[nodeId] && visited[opt.next]) ? 'rgba(68, 180, 120, 0.5)' : 'rgba(100, 120, 140, 0.3)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(gox + from.x, goy + from.y);
              ctx.lineTo(gox + to.x, goy + to.y);
              ctx.stroke();
            }
          }
        }

        // Draw nodes
        for (const [nodeId, pos] of Object.entries(graphNodes)) {
          const nx = gox + pos.x;
          const ny = goy + pos.y;
          let fillColor = '#334455';
          let strokeColor = '#556677';
          if (nodeId === currentNode) {
            fillColor = '#ddaa22';
            strokeColor = '#ffcc44';
          } else if (visited[nodeId]) {
            fillColor = '#227744';
            strokeColor = '#44bb66';
          }
          ctx.fillStyle = fillColor;
          ctx.beginPath();
          ctx.arc(nx, ny, 14, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.fillStyle = '#ffffff';
          ctx.font = '8px monospace';
          ctx.textAlign = 'center';
          const label = nodeId.length > 8 ? nodeId.substring(0, 7) + '..' : nodeId;
          ctx.fillText(label, nx, ny + 3);
          ctx.textAlign = 'left';
        }

        // Flags display
        const flagKeys = Object.keys(flags);
        if (flagKeys.length > 0) {
          ctx.fillStyle = '#667788';
          ctx.font = '12px monospace';
          ctx.fillText('Flags set:', GRAPH_X + 15, H - 60);
          ctx.fillStyle = '#88ddaa';
          ctx.font = '11px monospace';
          for (let i = 0; i < flagKeys.length; i++) {
            ctx.fillText('* ' + flagKeys[i], GRAPH_X + 20, H - 40 + i * 16);
          }
        }

        // Legend
        ctx.font = '10px monospace';
        const ly = H - 110;
        ctx.fillStyle = '#ddaa22';
        ctx.fillRect(GRAPH_X + 15, ly, 10, 10);
        ctx.fillStyle = '#aabbcc';
        ctx.fillText('Current', GRAPH_X + 30, ly + 9);

        ctx.fillStyle = '#227744';
        ctx.fillRect(GRAPH_X + 15, ly + 16, 10, 10);
        ctx.fillStyle = '#aabbcc';
        ctx.fillText('Visited', GRAPH_X + 30, ly + 25);

        ctx.fillStyle = '#334455';
        ctx.fillRect(GRAPH_X + 15, ly + 32, 10, 10);
        ctx.fillStyle = '#aabbcc';
        ctx.fillText('Unvisited', GRAPH_X + 30, ly + 41);
      }

      canvas.addEventListener('click', function(e) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (W / rect.width);
        const my = (e.clientY - rect.top) * (H / rect.height);

        if (currentNode === null) {
          // Restart
          currentNode = 'start';
          for (const k in flags) delete flags[k];
          for (const k in visited) delete visited[k];
          visited['start'] = true;
          if (dialog['start'].setFlag) flags[dialog['start'].setFlag] = true;
          draw();
          return;
        }

        if (mx > DIALOG_W) return;

        const node = dialog[currentNode];
        const options = getActiveOptions(node);

        const words = node.text.split(' ');
        let line = '';
        let ty = 65;
        for (const word of words) {
          const test = line + word + ' ';
          if (test.length * 8.4 > DIALOG_W - 40) {
            line = word + ' ';
            ty += 20;
          } else {
            line = test;
          }
        }
        const optY = ty + 50;

        for (let i = 0; i < options.length; i++) {
          const oy = optY + i * 40;
          if (mx >= 20 && mx <= DIALOG_W - 20 && my >= oy && my <= oy + 32) {
            const chosen = options[i];
            currentNode = chosen.next;
            if (currentNode && dialog[currentNode]) {
              visited[currentNode] = true;
              if (dialog[currentNode].setFlag) {
                flags[dialog[currentNode].setFlag] = true;
              }
            }
            draw();
            return;
          }
        }
      });

      draw();
    })();
  </script>
</BaseLayout>
