---
import BaseLayout from '../../layouts/BaseLayout.astro';
const base = import.meta.env.BASE_URL;
---

<BaseLayout title="Module 06: Tower Defense">
  <div class="container page-content">
    <div class="module-header">
      <div class="module-number">Module 06</div>
      <h1>Tower Defense</h1>
      <p class="module-theme">Optimizing placement to control the flow of enemies through space</p>
    </div>

    <hr />

    <h2>Week 1: History &amp; Design Theory</h2>

    <h3>The Origin</h3>
    <p><strong>Rampart</strong> (Atari, 1990) is the game most often cited as the ancestor of tower defense, though it did not look like what we now call the genre. Players placed castle walls on a grid, cannons fired automatically at approaching ships, and between rounds you scrambled to repair your fortifications before the next wave. The loop &mdash; build, defend, repair, repeat &mdash; was the seed. But the critical ingredient was spatial strategy: you were not controlling a character; you were shaping the battlefield itself. Where you placed your walls determined whether enemies could breach them. Rampart was an arcade game and a modest commercial success, but its design DNA would lie dormant for nearly two decades before the genre it inspired exploded into the mainstream.</p>

    <h3>How the Genre Evolved</h3>
    <p><strong>Desktop Tower Defense</strong> (Paul Preece, 2007) was a free Flash game that became a phenomenon. Its genius was simplicity: enemies walked from one side of an open grid to the other, and you placed towers anywhere on the grid to create a maze. The enemies pathfound around your towers in real time, so every placement decision reshaped the battlefield. This was the game that taught a generation of players (and developers) what "tower defense" meant. It demonstrated that the genre's core appeal was not action but optimization: you were designing a system, not executing reflexes.</p>

    <p><strong>Plants vs. Zombies</strong> (PopCap Games, 2009) simplified the formula for a mass audience. Instead of a free-form grid, it used lanes &mdash; zombies marched in straight horizontal lines, and you planted defenders in a grid that snapped to those lanes. This removed pathfinding complexity and replaced it with resource management (sunlight as currency) and personality (every plant and zombie had distinct character). Plants vs. Zombies proved that tower defense did not require the player to understand algorithms; it just needed to feel like a series of interesting decisions about where to spend limited resources.</p>

    <p><strong>Bloons TD</strong> (Ninja Kiwi, 2007 onward) and <strong>Kingdom Rush</strong> (Ironhide, 2012) pushed depth in different directions. Bloons TD gave each tower branching upgrade paths, turning tower selection into a build-order optimization problem with hundreds of viable strategies. Kingdom Rush introduced hero units and fixed paths (no maze-building), focusing the player's attention on upgrade timing and ability usage. Together, these games demonstrated the genre's range: from open-grid mazing to fixed-path resource optimization, from casual to deeply strategic.</p>

    <h3>What Makes Tower Defense Great</h3>
    <p>Tower defense is the rare genre where the player is a systems architect, not a performer. In a platformer or a shooter, success comes from execution &mdash; timing a jump, landing a shot. In tower defense, success comes from design: you build a machine (your tower layout) and then watch it run against an input (the enemy wave). The enemies are the test suite; your tower layout is the system under test. When it works, you feel clever. When it fails, you know exactly which design decision was wrong, and you want to try again.</p>

    <h3>The Essential Mechanic</h3>
    <p><strong>Optimizing placement to control the flow of enemies through space</strong> &mdash; the player builds static defenses whose positions determine how mobile enemies traverse the map, and victory comes from designing the most efficient arrangement.</p>

    <hr />

    <h2>Week 2: Build the MVP</h2>

    <h3>What You're Building</h3>
    <p>A single-player tower defense game on a grid-based map. Enemies spawn in waves and follow a path toward a goal. The player places towers on the grid using currency earned from kills. Towers automatically target and shoot enemies within range. If too many enemies reach the goal, the player loses. The game should have at least 3 tower types, 5+ waves, and a basic upgrade system.</p>

    <h3>Core Concepts (Must Implement)</h3>

    <h4>1. A* Pathfinding</h4>
    <p>This is the big new concept for this module. A* is a graph search algorithm that finds the shortest path between two points. It works on your grid: each cell is a node, walkable cells are connected to their neighbors, and towers (or walls) are impassable. A* uses a heuristic (an estimate of remaining distance) to explore promising paths first, making it dramatically faster than brute-force search.</p>
    <p>Think of A* as a priority-queue-driven BFS. You maintain an open set (cells to explore) sorted by <code>f(n) = g(n) + h(n)</code>, where <code>g(n)</code> is the cost so far and <code>h(n)</code> is the heuristic estimate to the goal. At each step, you pop the lowest-cost node, check if it is the goal, and if not, expand its neighbors.</p>
    <pre is:raw><code>function aStar(grid, start, goal):
    openSet = PriorityQueue()
    openSet.add(start, priority=0)
    cameFrom = {}
    gScore = { start: 0 }

    while openSet is not empty:
        current = openSet.popLowest()

        if current == goal:
            return reconstructPath(cameFrom, current)

        for neighbor in getWalkableNeighbors(grid, current):
            tentativeG = gScore[current] + 1   // uniform cost
            if tentativeG &lt; gScore.getOrDefault(neighbor, INFINITY):
                cameFrom[neighbor] = current
                gScore[neighbor] = tentativeG
                f = tentativeG + heuristic(neighbor, goal)
                openSet.add(neighbor, priority=f)

    return null  // no path exists

function heuristic(a, b):
    // Manhattan distance for 4-directional grid:
    return abs(a.x - b.x) + abs(a.y - b.y)</code></pre>
    <p><strong>Why it matters:</strong> A* is one of the most universally useful algorithms in computer science. Outside of games, it powers GPS routing, network packet routing, robot navigation, and dependency resolution. The deeper lesson is about informed search: when you have a heuristic (an estimate that never overestimates), you can explore large state spaces efficiently. You will use pathfinding or its variants in more contexts than you expect.</p>

    <div class="demo-container">
      <div class="demo-label">Interactive: A* Pathfinding Visualizer</div>
      <p class="demo-hint">Click cells to toggle walls (black). The green cell is the start; the red cell is the goal. Press "Step" to advance the algorithm one node at a time, or "Run" to animate the full search. Blue cells are the open set (candidates), gray cells are the closed set (already evaluated), and the amber path is the final route.</p>
      <canvas id="demo-astar" width="760" height="400"></canvas>
      <div class="demo-controls">
        <button id="astar-step-btn">Step</button>
        <button id="astar-run-btn">Run</button>
        <button id="astar-reset-btn">Reset</button>
        <span class="value-display" id="astar-status">Click cells to add walls, then Step or Run</span>
      </div>
    </div>

    <hr />

    <h4>2. Placement Systems</h4>
    <p>The player needs to place towers on the grid. This means you need a <strong>build mode</strong> state: when the player selects a tower type, the game enters a mode where clicking on the grid attempts to place that tower. Placement requires validation: is the cell empty? Can the player afford the tower? And critically &mdash; if your game allows maze-building &mdash; will this placement still leave a valid path for enemies?</p>
    <pre is:raw><code>function onGridClick(cellX, cellY, selectedTowerType):
    if not isValidPlacement(cellX, cellY):
        showError("Cannot place here")
        return

    if player.gold &lt; selectedTowerType.cost:
        showError("Not enough gold")
        return

    // If maze-building: check that placement doesn't block all paths
    grid[cellY][cellX] = BLOCKED
    testPath = aStar(grid, enemySpawn, goal)
    if testPath == null:
        grid[cellY][cellX] = EMPTY     // revert
        showError("Would block enemy path")
        return

    player.gold -= selectedTowerType.cost
    createTower(cellX, cellY, selectedTowerType)

function isValidPlacement(cellX, cellY):
    return grid[cellY][cellX] == EMPTY
       and not isOnPath(cellX, cellY)   // for fixed-path maps
       and isInBuildableArea(cellX, cellY)</code></pre>
    <p><strong>Why it matters:</strong> This is input validation with transactional rollback. You tentatively apply a state change (mark the cell as blocked), validate it against a constraint (path still exists), and either commit or revert. The "would block enemy path" check is a constraint satisfaction problem &mdash; you must verify that a proposed change does not violate a system invariant before committing it.</p>

    <hr />

    <h4>3. Economy / Resource Management</h4>
    <p>Towers cost gold. Enemies drop gold when killed. The player starts with enough gold for a few towers and must earn the rest through successful defense. This creates the fundamental tension of tower defense: spend now on cheap towers for immediate defense, or save for expensive towers that pay off later. The economy system is a simple ledger: income events (enemy killed) and expense events (tower purchased, tower upgraded).</p>
    <pre is:raw><code>player = {
    gold: 200,         // starting gold
    lives: 20          // HP -- enemies that reach the goal cost lives
}

TOWER_COSTS = {
    "basic":  100,
    "sniper": 200,
    "splash": 150
}

function onEnemyKilled(enemy):
    player.gold += enemy.bounty

function purchaseTower(type):
    cost = TOWER_COSTS[type]
    if player.gold >= cost:
        player.gold -= cost
        return true
    return false</code></pre>
    <p><strong>Why it matters:</strong> This is resource budgeting. There is always a trade-off between immediate throughput and long-term efficiency. The player who spends all their gold on cheap towers survives early but stalls late. The player who hoards gold has a powerful endgame but might lose lives in the meantime. Balancing an economy is one of the hardest design problems in games &mdash; the math is simple, but the feel requires extensive playtesting.</p>

    <hr />

    <h4>4. Targeting AI for Towers</h4>
    <p>Each tower needs to decide which enemy to shoot. This is a strategy pattern: the tower has a targeting mode (nearest, first in path, strongest, weakest/lowest HP), and each mode is a different sorting function applied to the list of enemies within range. The player may be able to switch targeting modes per tower, or different tower types may have fixed strategies.</p>
    <pre is:raw><code>function getTarget(tower, enemies):
    inRange = enemies.filter(e => distance(tower, e) &lt;= tower.range)

    if inRange.isEmpty():
        return null

    switch tower.targetingMode:
        case "nearest":
            return inRange.sortBy(e => distance(tower, e)).first()
        case "first":
            return inRange.sortBy(e => e.distanceAlongPath).last()
        case "strongest":
            return inRange.sortBy(e => e.maxHP).last()
        case "weakest":
            return inRange.sortBy(e => e.currentHP).first()</code></pre>
    <p><strong>Why it matters:</strong> This is the strategy pattern in a textbook application. Each targeting mode is an interchangeable algorithm with the same interface: given a list of candidates, return the best one. The key design decision is not which strategy is "best" &mdash; it is giving the player the ability to choose the right strategy for the current situation.</p>

    <hr />

    <h4>5. Range Detection</h4>
    <p>Every tower has a range radius. Each frame (or each tower tick), you need to determine which enemies are within range. The basic approach is a circle-based distance check: if the Euclidean distance between the tower center and the enemy position is less than or equal to the tower's range, the enemy is in range. For visual feedback, draw the range circle when the player hovers over or selects a tower.</p>
    <pre is:raw><code>function isInRange(tower, enemy):
    dx = tower.x - enemy.x
    dy = tower.y - enemy.y
    distSquared = dx * dx + dy * dy
    return distSquared &lt;= tower.range * tower.range
    // Compare squared values to avoid expensive sqrt

function getEnemiesInRange(tower, allEnemies):
    return allEnemies.filter(e => isInRange(tower, e))</code></pre>
    <p><strong>Why it matters:</strong> Range detection is a spatial query, and the squared-distance optimization is a micro-optimization you will see everywhere in game development. At small scale, iterating over all enemies per tower per frame is fine. At large scale (hundreds of towers, thousands of enemies), you would need spatial indexing &mdash; quadtrees, spatial hash grids, or similar structures. Start with the brute-force check, and understand why spatial indexing exists for when you need it.</p>

    <div class="demo-container">
      <div class="demo-label">Interactive: Tower Range &amp; Targeting Demo</div>
      <p class="demo-hint">Click anywhere on the canvas to place a tower. Enemies walk along a fixed path (shown as gray dots). The tower's range circle appears. Use the dropdown to switch targeting modes (Nearest, First along path, Strongest) and watch which enemy the tower selects. Projectiles fly from the tower to its target.</p>
      <canvas id="demo-targeting" width="760" height="400"></canvas>
      <div class="demo-controls">
        <select id="tgt-mode-select">
          <option value="nearest">Nearest</option>
          <option value="first">First (farthest along path)</option>
          <option value="strongest">Strongest (most HP)</option>
        </select>
        <button id="tgt-reset-btn">Reset</button>
        <span class="value-display" id="tgt-status">Click to place a tower</span>
      </div>
    </div>

    <hr />

    <h4>6. Upgrade Trees</h4>
    <p>After placing a tower, the player can spend additional gold to upgrade it. In the simplest form, upgrades increase damage, range, or fire rate. In more complex designs, towers have branching upgrade paths: a basic tower might upgrade into either a "sniper" (high damage, slow fire, long range) or a "machine gun" (low damage, fast fire, short range). Upgrades are data, not code: define them in a configuration structure and apply stat modifications.</p>
    <pre is:raw><code>UPGRADE_TREE = {
    "basic": {
        "path_a": [
            { name: "Sharper Arrows", cost: 100, damage: +5 },
            { name: "Sniper Scope",   cost: 200, damage: +10, range: +2 },
            { name: "Railgun",        cost: 500, damage: +30, range: +3 }
        ],
        "path_b": [
            { name: "Faster Draw",    cost: 80,  fireRate: +0.5 },
            { name: "Twin Barrels",   cost: 180, fireRate: +1.0 },
            { name: "Gatling Tower",  cost: 400, fireRate: +2.0, damage: +3 }
        ]
    }
}

function upgradeTower(tower, pathId):
    path = UPGRADE_TREE[tower.type][pathId]
    nextUpgrade = path[tower.upgradeLevel[pathId]]
    if player.gold >= nextUpgrade.cost:
        player.gold -= nextUpgrade.cost
        applyStatModifiers(tower, nextUpgrade)
        tower.upgradeLevel[pathId] += 1</code></pre>
    <p><strong>Why it matters:</strong> This is data-driven configuration &mdash; the same approach you use for feature flags, tiered pricing plans, or role-based permissions. The upgrade tree is a static data structure that the game engine interprets at runtime. Adding a new upgrade path means adding data, not writing new code. This separation of data and logic is one of the most important architectural principles in software engineering, and game developers learned it early because designers need to tweak numbers constantly without recompiling.</p>

    <hr />

    <h4>7. Wave Design (Revisited)</h4>
    <p>You built wave systems in Module 03 (Top-Down Shooter), but tower defense waves work differently. The player is stationary, so waves must create pressure through composition and pacing, not through surrounding the player. A good wave system mixes enemy types (fast but fragile, slow but tanky, groups of weak enemies, single powerful enemies), adjusts spawn rates, and introduces new threats at predictable intervals so the player can plan.</p>
    <pre is:raw><code>WAVES = [
    { enemies: [{ type: "basic", count: 10, interval: 1.0 }] },
    { enemies: [{ type: "basic", count: 15, interval: 0.8 }] },
    { enemies: [
        { type: "basic", count: 10, interval: 0.8 },
        { type: "fast",  count: 5,  interval: 0.5, delay: 5.0 }
    ]},
    { enemies: [{ type: "tank", count: 3, interval: 2.0 }] },
    // Wave 5: boss wave
    { enemies: [
        { type: "basic", count: 20, interval: 0.5 },
        { type: "boss",  count: 1,  interval: 0,   delay: 10.0 }
    ]}
]

function startWave(waveIndex):
    wave = WAVES[waveIndex]
    for group in wave.enemies:
        scheduleSpawns(group.type, group.count, group.interval, group.delay)</code></pre>
    <p><strong>Why it matters:</strong> Wave design is systematic stress-testing of the player's defenses. Each wave is a pressure pattern: sustained pressure (many weak enemies), burst pressure (a group of fast enemies), heavy pressure (a tank with lots of HP), and peak events (a boss). The data-driven wave format (an array of objects with types, counts, and intervals) is a declarative configuration pattern &mdash; adding new waves means adding data, not writing new code.</p>

    <hr />

    <h4>8. Path Recalculation</h4>
    <p>If your game allows the player to place towers that block the enemy path (maze-building), you must handle path recalculation. When a tower is placed, all enemies currently navigating need updated paths. There are two common approaches: <strong>fixed paths</strong> (enemies follow a predetermined route and towers can only be placed alongside it) or <strong>dynamic paths</strong> (enemies pathfind in real time and towers reshape the maze). Fixed paths are simpler and perfectly valid for an MVP. Dynamic paths are more interesting but require careful performance management.</p>
    <pre is:raw><code>// Option A: Fixed path (defined at map creation)
FIXED_PATH = [(0,5), (1,5), (2,5), (2,6), (2,7), ...]

function moveEnemy(enemy):
    target = FIXED_PATH[enemy.pathIndex]
    moveToward(enemy, target)
    if reachedTarget(enemy, target):
        enemy.pathIndex += 1
        if enemy.pathIndex >= FIXED_PATH.length:
            enemyReachedGoal(enemy)

// Option B: Dynamic path (recalculate on tower placement)
function onTowerPlaced():
    newPath = aStar(grid, spawn, goal)
    if newPath == null:
        rejectPlacement()  // handled in placement validation
        return
    // Update all active enemies:
    for enemy in activeEnemies:
        enemy.path = aStar(grid, enemy.currentCell, goal)</code></pre>
    <p><strong>Why it matters:</strong> Path recalculation is cache invalidation. When the grid changes (a tower is placed), all cached paths are stale and must be recomputed. Fixed paths are the simple option &mdash; predictable, no invalidation needed. Dynamic paths are more flexible, but you pay the cost of recalculation every time the grid changes. Choosing between them is an architecture decision with familiar trade-offs: simplicity and predictability versus flexibility and computational cost.</p>

    <hr />

    <h3>Putting It All Together</h3>
    <p>Below is a playable mini tower defense game combining every concept above: pathfinding, placement validation, economy, targeting AI, range detection, wave design, and path recalculation. Click to place towers, survive 5 waves, and manage your gold carefully.</p>

    <div class="demo-container">
      <div class="demo-label">Interactive: Mini Tower Defense</div>
      <p class="demo-hint">Select a tower type from the buttons below, then click on the grid to place it. Enemies follow a fixed path from the green start to the red goal. Towers automatically fire at enemies in range. Survive all 5 waves to win. Earn gold from kills to place more towers.</p>
      <canvas id="demo-td" width="760" height="460"></canvas>
      <div class="demo-controls">
        <button id="td-basic-btn" style="background:#3b82f6;">Basic (100g)</button>
        <button id="td-sniper-btn" style="background:#a855f7;">Sniper (200g)</button>
        <button id="td-splash-btn" style="background:#f97316;">Splash (150g)</button>
        <button id="td-start-btn">Start Wave</button>
        <span class="value-display" id="td-info">Gold: 300 | Lives: 20 | Wave: 0/5</span>
      </div>
    </div>

    <hr />

    <h3>Stretch Goals</h3>
    <ol>
      <li><strong>Multiple enemy paths / spawn points</strong> &mdash; Enemies enter from multiple edges of the map, forcing the player to defend in multiple directions simultaneously. This tests whether your pathfinding and placement systems generalize beyond a single start/end pair.</li>
      <li><strong>Tower selling with depreciation</strong> &mdash; Let the player sell towers for a percentage of their total investment (purchase + upgrades). This adds a "refactoring" mechanic: sometimes the optimal move is to tear down an old design and rebuild, accepting a resource loss for a better architecture.</li>
      <li><strong>Special abilities / active skills</strong> &mdash; Give the player a cooldown-based ability (a bomb that damages all enemies in an area, a freeze that slows a wave, a gold bonus). This introduces cooldown management &mdash; a timer-based system that prevents an action from being used again until a delay has elapsed.</li>
      <li><strong>Creep types with special behaviors</strong> &mdash; Flying enemies that ignore the ground path (bypassing your maze entirely), healing enemies that restore HP to nearby creeps, or shielded enemies that are immune to certain tower types. Each special behavior forces the player to diversify their defense strategy rather than relying on a single dominant approach.</li>
    </ol>

    <h3>MVP Spec</h3>
    <table>
      <thead>
        <tr><th>Feature</th><th>Required?</th></tr>
      </thead>
      <tbody>
        <tr><td>Grid-based map with defined path or pathfinding</td><td>Yes</td></tr>
        <tr><td>A* pathfinding (at minimum for initial path)</td><td>Yes</td></tr>
        <tr><td>Tower placement with validation (affordability, valid cell)</td><td>Yes</td></tr>
        <tr><td>At least 3 tower types with different stats</td><td>Yes</td></tr>
        <tr><td>Economy system (gold from kills, spent on towers)</td><td>Yes</td></tr>
        <tr><td>Targeting AI (at least one strategy; nearest is fine)</td><td>Yes</td></tr>
        <tr><td>Range detection and range visualization</td><td>Yes</td></tr>
        <tr><td>5+ enemy waves with escalating difficulty</td><td>Yes</td></tr>
        <tr><td>At least 2 enemy types (e.g., basic and fast)</td><td>Yes</td></tr>
        <tr><td>Lives system (enemies reaching goal cost lives)</td><td>Yes</td></tr>
        <tr><td>Game over when lives reach zero</td><td>Yes</td></tr>
        <tr><td>Basic upgrade system (at least 1 upgrade per tower type)</td><td>Yes</td></tr>
        <tr><td>Dynamic path recalculation on tower placement</td><td>Stretch</td></tr>
        <tr><td>Branching upgrade paths</td><td>Stretch</td></tr>
        <tr><td>Tower selling</td><td>Stretch</td></tr>
        <tr><td>Multiple spawn points</td><td>Stretch</td></tr>
        <tr><td>Flying / special enemy types</td><td>Stretch</td></tr>
        <tr><td>Active abilities with cooldowns</td><td>Stretch</td></tr>
      </tbody>
    </table>

    <h3>Deliverable</h3>
    <p>A playable single-player tower defense game. Enemies spawn in waves and follow a path toward a goal. The player places and upgrades towers using gold earned from kills. Towers automatically target and fire at enemies in range. The game ends when the player survives all waves (victory) or loses all lives (defeat). Submit a screen recording or playable link alongside your source code. Include a brief write-up (a few sentences is fine) explaining whether you chose fixed paths or dynamic pathfinding and why.</p>

    <h2>Analogies by Background</h2>

    <blockquote>
      <p>These analogies map game dev concepts to patterns you already know. Find your background below.</p>
    </blockquote>

    <h3>For Backend Developers</h3>
    <table>
      <thead>
        <tr><th>Concept</th><th>Analogy</th></tr>
      </thead>
      <tbody>
        <tr><td>A* Pathfinding</td><td>Query optimizer cost model or network packet routing &mdash; informed search using a heuristic to explore large state spaces efficiently</td></tr>
        <tr><td>Placement Systems</td><td>Request validation with transactional rollback &mdash; tentatively apply a change, check business rules / system invariants, commit or revert</td></tr>
        <tr><td>Economy / Resource Management</td><td>Capacity planning &mdash; budget allocation between immediate throughput (cheap infra now) and long-term efficiency (bigger investment later)</td></tr>
        <tr><td>Targeting AI for Towers</td><td>Load balancer algorithms (round-robin, least-connections, weighted) or cache eviction policies (LRU, LFU) &mdash; interchangeable strategies with the same interface</td></tr>
        <tr><td>Range Detection</td><td>Geo-spatial queries in PostGIS or geofencing services &mdash; at scale, brute-force becomes spatial indexing (R-trees, quadtrees)</td></tr>
        <tr><td>Upgrade Trees</td><td>Feature flags or tiered pricing configuration &mdash; static data structures interpreted at runtime, adding options means adding data not code</td></tr>
        <tr><td>Wave Design</td><td>Load test scenarios &mdash; sustained load, burst traffic, heavy requests, and peak events defined as declarative configuration (like CI/CD pipelines or job schedulers)</td></tr>
        <tr><td>Path Recalculation</td><td>CDN cache invalidation or routing table recomputation &mdash; when state changes, cached results are stale and must be recomputed</td></tr>
      </tbody>
    </table>

    <h3>For Frontend Developers</h3>
    <table>
      <thead>
        <tr><th>Concept</th><th>Analogy</th></tr>
      </thead>
      <tbody>
        <tr><td>A* Pathfinding</td><td>DOM traversal with a heuristic &mdash; like a best-first search through a component tree to find the optimal render path</td></tr>
        <tr><td>Placement Systems</td><td>Form validation with optimistic UI &mdash; show the change, validate against rules, revert the DOM if validation fails</td></tr>
        <tr><td>Economy / Resource Management</td><td>State budget in a Redux/Zustand store &mdash; every action (purchase/earn) is a dispatched event that updates a central balance</td></tr>
        <tr><td>Targeting AI for Towers</td><td>Event delegation with different handler strategies &mdash; the same listener interface, but the selection logic (nearest, first, strongest) is swappable</td></tr>
        <tr><td>Range Detection</td><td>Bounding-rect intersection checks (<code>getBoundingClientRect</code>) for detecting which elements overlap a circular region</td></tr>
        <tr><td>Upgrade Trees</td><td>Nested component configuration objects &mdash; a JSON structure that defines what a component renders, extended by adding data</td></tr>
        <tr><td>Wave Design</td><td>Declarative animation sequences (CSS keyframes or Framer Motion) &mdash; timed events defined as configuration, not imperative code</td></tr>
        <tr><td>Path Recalculation</td><td>Virtual DOM diffing after state change &mdash; when the underlying data changes, the rendered output must be recomputed and reconciled</td></tr>
      </tbody>
    </table>

    <h3>For Data / ML Engineers</h3>
    <table>
      <thead>
        <tr><th>Concept</th><th>Analogy</th></tr>
      </thead>
      <tbody>
        <tr><td>A* Pathfinding</td><td>Best-first search through a state space, like beam search in sequence models &mdash; a heuristic guides exploration toward the goal</td></tr>
        <tr><td>Placement Systems</td><td>Constraint satisfaction with rollback &mdash; like checking that adding a feature to a model does not violate multicollinearity constraints</td></tr>
        <tr><td>Economy / Resource Management</td><td>Compute budget allocation &mdash; spend GPU hours on quick experiments now or save for a large training run later</td></tr>
        <tr><td>Targeting AI for Towers</td><td>Scoring functions for candidate selection &mdash; rank items by different criteria (distance, strength), same interface as ranking models or selection policies in RL</td></tr>
        <tr><td>Range Detection</td><td>k-nearest-neighbors spatial query &mdash; at scale, brute-force distance checks become KD-trees or approximate nearest neighbor indexes</td></tr>
        <tr><td>Upgrade Trees</td><td>Hyperparameter configuration trees &mdash; branching options defined as data (YAML/JSON), parsed and applied at runtime</td></tr>
        <tr><td>Wave Design</td><td>Synthetic data generation schedules &mdash; batches of varying size, type, and difficulty defined declaratively, like a data pipeline DAG</td></tr>
        <tr><td>Path Recalculation</td><td>Recomputing a downstream feature when an upstream input changes &mdash; like cache invalidation in a feature store or re-running a DAG node</td></tr>
      </tbody>
    </table>

    <h3>Discussion Questions</h3>
    <ol>
      <li><strong>A* in the real world.</strong> A* requires an admissible heuristic &mdash; one that never overestimates the true cost. Manhattan distance works for a 4-directional grid. Where else have you encountered heuristic-driven search or optimization in backend systems? How does a database query optimizer's cost model relate to A*'s heuristic?</li>
      <li><strong>Static vs. dynamic routing.</strong> Fixed paths are simpler but less interesting. Dynamic pathfinding is more complex but lets the player build mazes. How does this trade-off mirror the choice between static routing and dynamic routing in network infrastructure or microservice mesh configurations?</li>
      <li><strong>Economy balance as system design.</strong> If towers are too cheap, the game is trivially easy. If enemies give too little gold, the game is impossible. How do you approach balancing an economy like this? What does playtesting an in-game economy have in common with capacity planning or cost optimization for cloud infrastructure?</li>
      <li><strong>Performance and spatial queries.</strong> In an MVP, checking every enemy against every tower each frame is fine. At what scale does this break down, and what data structures (quadtrees, spatial hashing) would you reach for? How do these relate to spatial indexing in databases or geofencing services you have worked with?</li>
    </ol>

    <hr />

    <h2>Prerequisites</h2>
    <ul>
      <li><strong>Module 01 (Pong) &mdash; recommended.</strong> Pong introduces the game loop, input handling, and collision detection. Tower defense builds on all of these fundamentals.</li>
      <li><strong>Module 03 (Top-Down Shooter) &mdash; recommended.</strong> The top-down shooter introduces wave spawning, enemy AI, and projectile systems. Tower defense reuses all three concepts but shifts the player's role from direct combatant to architect. If you completed Module 03, you will find the wave and projectile systems familiar; the new challenges are pathfinding, placement, and economy.</li>
    </ul>

    <nav class="module-nav">
      <a href={`${base}modules/05-puzzle/`}>&larr; Module 05: Puzzle Game</a>
      <a href={`${base}modules/07-roguelike/`}>Module 07: Roguelike &rarr;</a>
    </nav>
  </div>
</BaseLayout>

<script>
// ============================================================
// A* HELPER (shared across demos)
// ============================================================
function aStarSearch(grid, startR, startC, goalR, goalC, rows, cols) {
  const key = (r, c) => r * cols + c;
  const startKey = key(startR, startC);
  const goalKey = key(goalR, goalC);

  const gScore = new Map();
  const fScore = new Map();
  const cameFrom = new Map();
  const openSet = new Set([startKey]);
  const closedSet = new Set();

  gScore.set(startKey, 0);
  fScore.set(startKey, Math.abs(goalR - startR) + Math.abs(goalC - startC));

  function heuristic(r, c) {
    return Math.abs(goalR - r) + Math.abs(goalC - c);
  }

  function getLowest() {
    let best = null, bestF = Infinity;
    for (const k of openSet) {
      const f = fScore.get(k) || Infinity;
      if (f < bestF) { bestF = f; best = k; }
    }
    return best;
  }

  function reconstructPath(endKey) {
    const path = [];
    let cur = endKey;
    while (cur !== undefined) {
      path.unshift({ r: Math.floor(cur / cols), c: cur % cols });
      cur = cameFrom.get(cur);
    }
    return path;
  }

  // Step-by-step mode: returns state object
  const state = {
    openSet, closedSet, gScore, fScore, cameFrom,
    done: false, found: false, path: null,
    currentKey: null
  };

  state.step = function() {
    if (state.done) return state;
    if (openSet.size === 0) { state.done = true; return state; }

    const currentKey = getLowest();
    state.currentKey = currentKey;
    const cr = Math.floor(currentKey / cols), cc = currentKey % cols;

    if (currentKey === goalKey) {
      state.done = true;
      state.found = true;
      state.path = reconstructPath(currentKey);
      return state;
    }

    openSet.delete(currentKey);
    closedSet.add(currentKey);

    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
    for (const [dr, dc] of dirs) {
      const nr = cr + dr, nc = cc + dc;
      if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;
      if (grid[nr][nc] === 1) continue; // wall
      const nk = key(nr, nc);
      if (closedSet.has(nk)) continue;

      const tentG = (gScore.get(currentKey) || 0) + 1;
      if (tentG < (gScore.get(nk) || Infinity)) {
        cameFrom.set(nk, currentKey);
        gScore.set(nk, tentG);
        fScore.set(nk, tentG + heuristic(nr, nc));
        openSet.add(nk);
      }
    }
    return state;
  };

  // Run to completion
  state.runAll = function() {
    while (!state.done) state.step();
    return state;
  };

  return state;
}

// ============================================================
// DEMO 1: A* PATHFINDING VISUALIZER
// ============================================================
(function() {
  const canvas = document.getElementById('demo-astar');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const stepBtn = document.getElementById('astar-step-btn');
  const runBtn = document.getElementById('astar-run-btn');
  const resetBtn = document.getElementById('astar-reset-btn');
  const statusEl = document.getElementById('astar-status');

  const GRID_COLS = 25, GRID_ROWS = 13;
  const CELL = Math.floor(Math.min((W - 20) / GRID_COLS, (H - 20) / GRID_ROWS));
  const GW = GRID_COLS * CELL, GH = GRID_ROWS * CELL;
  const OX = (W - GW) / 2, OY = (H - GH) / 2;

  const START_R = 6, START_C = 1;
  const GOAL_R = 6, GOAL_C = GRID_COLS - 2;

  let grid, searchState, animRunning;

  function initGrid() {
    grid = Array.from({length: GRID_ROWS}, () => Array(GRID_COLS).fill(0));
    searchState = null;
    animRunning = false;
    statusEl.textContent = 'Click cells to add walls, then Step or Run';
  }

  function startSearch() {
    searchState = aStarSearch(grid, START_R, START_C, GOAL_R, GOAL_C, GRID_ROWS, GRID_COLS);
  }

  function render() {
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#0f0f1a';
    ctx.fillRect(0, 0, W, H);

    for (let r = 0; r < GRID_ROWS; r++) {
      for (let c = 0; c < GRID_COLS; c++) {
        const x = OX + c * CELL, y = OY + r * CELL;
        const k = r * GRID_COLS + c;

        // Determine cell color
        let color = '#1a1a2e'; // empty
        if (grid[r][c] === 1) {
          color = '#1e293b'; // wall
        } else if (searchState) {
          if (searchState.path && searchState.path.some(p => p.r === r && p.c === c)) {
            color = '#d4a017'; // path
          } else if (searchState.closedSet.has(k)) {
            color = '#374151'; // closed
          } else if (searchState.openSet.has(k)) {
            color = '#1d4ed8'; // open
          }
        }

        // Start / Goal override
        if (r === START_R && c === START_C) color = '#22c55e';
        if (r === GOAL_R && c === GOAL_C) color = '#ef4444';

        ctx.fillStyle = color;
        ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);

        // Show f-score for open/closed cells
        if (searchState && searchState.fScore.has(k) && grid[r][c] !== 1 &&
            !(r === START_R && c === START_C) && !(r === GOAL_R && c === GOAL_C)) {
          const f = searchState.fScore.get(k);
          ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.font = '9px "JetBrains Mono", monospace';
          ctx.textAlign = 'center';
          ctx.fillText(f, x + CELL / 2, y + CELL / 2 + 3);
        }
      }
    }

    // Grid lines
    ctx.strokeStyle = '#333355';
    ctx.lineWidth = 0.5;
    for (let r = 0; r <= GRID_ROWS; r++) {
      ctx.beginPath(); ctx.moveTo(OX, OY + r * CELL); ctx.lineTo(OX + GW, OY + r * CELL); ctx.stroke();
    }
    for (let c = 0; c <= GRID_COLS; c++) {
      ctx.beginPath(); ctx.moveTo(OX + c * CELL, OY); ctx.lineTo(OX + c * CELL, OY + GH); ctx.stroke();
    }

    // Legend
    ctx.font = '11px "Inter", sans-serif';
    ctx.textAlign = 'left';
    const ly = OY + GH + 2;
    const items = [
      { color: '#22c55e', label: 'Start' },
      { color: '#ef4444', label: 'Goal' },
      { color: '#1e293b', label: 'Wall' },
      { color: '#1d4ed8', label: 'Open' },
      { color: '#374151', label: 'Closed' },
      { color: '#d4a017', label: 'Path' }
    ];
    let lx = OX;
    for (const it of items) {
      ctx.fillStyle = it.color;
      ctx.fillRect(lx, ly, 10, 10);
      ctx.fillStyle = '#94a3b8';
      ctx.fillText(it.label, lx + 14, ly + 9);
      lx += 70;
    }
  }

  canvas.addEventListener('click', (e) => {
    if (searchState && searchState.done) return; // don't modify during/after search
    if (searchState) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;
    const c = Math.floor((mx - OX) / CELL);
    const r = Math.floor((my - OY) / CELL);
    if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) return;
    if (r === START_R && c === START_C) return;
    if (r === GOAL_R && c === GOAL_C) return;
    grid[r][c] = grid[r][c] ? 0 : 1;
    render();
  });

  stepBtn.addEventListener('click', () => {
    if (!searchState) startSearch();
    if (searchState.done) return;
    searchState.step();
    if (searchState.done) {
      statusEl.textContent = searchState.found
        ? 'Path found! Length: ' + searchState.path.length
        : 'No path exists.';
    } else {
      statusEl.textContent = 'Open: ' + searchState.openSet.size + ' | Closed: ' + searchState.closedSet.size;
    }
    render();
  });

  runBtn.addEventListener('click', () => {
    if (animRunning) return;
    if (!searchState) startSearch();
    if (searchState.done) return;
    animRunning = true;
    function tick() {
      if (searchState.done) {
        animRunning = false;
        statusEl.textContent = searchState.found
          ? 'Path found! Length: ' + searchState.path.length
          : 'No path exists.';
        render();
        return;
      }
      searchState.step();
      statusEl.textContent = 'Open: ' + searchState.openSet.size + ' | Closed: ' + searchState.closedSet.size;
      render();
      setTimeout(tick, 30);
    }
    tick();
  });

  resetBtn.addEventListener('click', () => {
    animRunning = false;
    initGrid();
    render();
  });

  initGrid();
  render();
})();

// ============================================================
// DEMO 2: TOWER RANGE & TARGETING DEMO
// ============================================================
(function() {
  const canvas = document.getElementById('demo-targeting');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const modeSelect = document.getElementById('tgt-mode-select');
  const resetBtn = document.getElementById('tgt-reset-btn');
  const statusEl = document.getElementById('tgt-status');

  // Define a path as a series of waypoints (pixel coords)
  const PATH = [];
  const pathSteps = 20;
  // S-shaped path
  const waypoints = [
    { x: 0, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 300 },
    { x: 500, y: 300 },
    { x: 500, y: 100 },
    { x: W, y: 100 }
  ];
  // Interpolate between waypoints for smooth path
  for (let i = 0; i < waypoints.length - 1; i++) {
    const a = waypoints[i], b = waypoints[i + 1];
    const dist = Math.hypot(b.x - a.x, b.y - a.y);
    const steps = Math.max(1, Math.ceil(dist / 5));
    for (let s = 0; s < steps; s++) {
      const t = s / steps;
      PATH.push({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });
    }
  }
  PATH.push(waypoints[waypoints.length - 1]);

  const ENEMY_TYPES = [
    { name: 'basic', color: '#ef4444', radius: 8, speed: 0.8, maxHP: 100 },
    { name: 'fast', color: '#eab308', radius: 6, speed: 1.5, maxHP: 50 },
    { name: 'tank', color: '#22c55e', radius: 12, speed: 0.4, maxHP: 250 }
  ];

  let tower = null;
  let enemies = [];
  let projectiles = [];
  let targetMode = 'nearest';
  let lastShot = 0;
  const TOWER_RANGE = 150;
  const FIRE_RATE = 800; // ms between shots
  const PROJ_SPEED = 5;
  let running = true;

  function spawnEnemies() {
    enemies = [];
    // Spawn a mix of enemies at different path positions
    const types = [0, 0, 0, 1, 1, 2]; // 3 basic, 2 fast, 1 tank
    for (let i = 0; i < types.length; i++) {
      const et = ENEMY_TYPES[types[i]];
      enemies.push({
        pathIndex: -(i * 60), // stagger start
        x: PATH[0].x, y: PATH[0].y,
        type: et,
        hp: et.maxHP,
        alive: true
      });
    }
  }

  function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

  function getTarget() {
    if (!tower) return null;
    const inRange = enemies.filter(e => e.alive && dist(tower, e) <= TOWER_RANGE);
    if (inRange.length === 0) return null;

    switch (targetMode) {
      case 'nearest':
        return inRange.sort((a, b) => dist(tower, a) - dist(tower, b))[0];
      case 'first':
        return inRange.sort((a, b) => b.pathIndex - a.pathIndex)[0];
      case 'strongest':
        return inRange.sort((a, b) => b.type.maxHP - a.type.maxHP)[0];
    }
    return inRange[0];
  }

  function update(now) {
    // Move enemies along path
    for (const e of enemies) {
      if (!e.alive) continue;
      e.pathIndex += e.type.speed;
      const idx = Math.max(0, Math.min(PATH.length - 1, Math.floor(e.pathIndex)));
      e.x = PATH[idx].x;
      e.y = PATH[idx].y;
      if (e.pathIndex >= PATH.length - 1) {
        e.alive = false; // reached end
      }
    }

    // Tower shooting
    if (tower && now - lastShot > FIRE_RATE) {
      const target = getTarget();
      if (target) {
        projectiles.push({
          x: tower.x, y: tower.y,
          targetId: enemies.indexOf(target),
          active: true
        });
        lastShot = now;
      }
    }

    // Move projectiles
    for (const p of projectiles) {
      if (!p.active) continue;
      const target = enemies[p.targetId];
      if (!target || !target.alive) { p.active = false; continue; }
      const dx = target.x - p.x, dy = target.y - p.y;
      const d = Math.hypot(dx, dy);
      if (d < 8) {
        target.hp -= 25;
        if (target.hp <= 0) target.alive = false;
        p.active = false;
      } else {
        p.x += (dx / d) * PROJ_SPEED;
        p.y += (dy / d) * PROJ_SPEED;
      }
    }
    projectiles = projectiles.filter(p => p.active);

    // Respawn enemies if all gone
    if (enemies.every(e => !e.alive)) {
      spawnEnemies();
    }
  }

  function render() {
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#0f0f1a';
    ctx.fillRect(0, 0, W, H);

    // Draw path
    ctx.strokeStyle = '#333355';
    ctx.lineWidth = 20;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(PATH[0].x, PATH[0].y);
    for (let i = 1; i < PATH.length; i += 3) {
      ctx.lineTo(PATH[i].x, PATH[i].y);
    }
    ctx.stroke();

    // Path dots
    ctx.fillStyle = '#4a4a6a';
    for (let i = 0; i < PATH.length; i += 20) {
      ctx.beginPath();
      ctx.arc(PATH[i].x, PATH[i].y, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Tower range
    if (tower) {
      ctx.strokeStyle = 'rgba(212,160,23,0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(tower.x, tower.y, TOWER_RANGE, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(212,160,23,0.05)';
      ctx.fill();

      // Tower body
      ctx.fillStyle = '#3b82f6';
      ctx.fillRect(tower.x - 12, tower.y - 12, 24, 24);
      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 2;
      ctx.strokeRect(tower.x - 12, tower.y - 12, 24, 24);

      // Targeting line to current target
      const target = getTarget();
      if (target) {
        ctx.strokeStyle = '#d4a017';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(tower.x, tower.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Highlight target
        ctx.strokeStyle = '#d4a017';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(target.x, target.y, target.type.radius + 4, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // Enemies
    for (const e of enemies) {
      if (!e.alive || e.pathIndex < 0) continue;
      ctx.fillStyle = e.type.color;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.type.radius, 0, Math.PI * 2);
      ctx.fill();

      // HP bar
      const barW = e.type.radius * 2;
      const hpPct = e.hp / e.type.maxHP;
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(e.x - barW / 2, e.y - e.type.radius - 8, barW, 4);
      ctx.fillStyle = hpPct > 0.5 ? '#22c55e' : hpPct > 0.25 ? '#eab308' : '#ef4444';
      ctx.fillRect(e.x - barW / 2, e.y - e.type.radius - 8, barW * hpPct, 4);
    }

    // Projectiles
    ctx.fillStyle = '#d4a017';
    for (const p of projectiles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Instructions
    if (!tower) {
      ctx.fillStyle = '#94a3b8';
      ctx.font = '14px "Inter", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Click anywhere to place a tower', W / 2, H - 15);
    }

    // Legend
    ctx.font = '11px "Inter", sans-serif';
    ctx.textAlign = 'right';
    ctx.fillStyle = '#94a3b8';
    const lx = W - 15;
    ctx.fillText('Red = Basic (100 HP)', lx, 20);
    ctx.fillText('Yellow = Fast (50 HP)', lx, 36);
    ctx.fillText('Green = Tank (250 HP)', lx, 52);
    ctx.fillText('Mode: ' + targetMode, lx, 68);
  }

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;
    tower = { x: mx, y: my };
    statusEl.textContent = 'Tower placed! Targeting: ' + targetMode;
  });

  modeSelect.addEventListener('change', () => {
    targetMode = modeSelect.value;
    statusEl.textContent = 'Targeting mode: ' + targetMode;
  });

  resetBtn.addEventListener('click', () => {
    tower = null;
    projectiles = [];
    spawnEnemies();
    statusEl.textContent = 'Click to place a tower';
  });

  spawnEnemies();

  function loop() {
    update(performance.now());
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();

// ============================================================
// DEMO 3: MINI TOWER DEFENSE
// ============================================================
(function() {
  const canvas = document.getElementById('demo-td');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const basicBtn = document.getElementById('td-basic-btn');
  const sniperBtn = document.getElementById('td-sniper-btn');
  const splashBtn = document.getElementById('td-splash-btn');
  const startBtn = document.getElementById('td-start-btn');
  const infoEl = document.getElementById('td-info');

  const COLS = 19, ROWS = 11;
  const CELL = Math.floor(Math.min((W - 20) / COLS, (H - 60) / ROWS));
  const GW = COLS * CELL, GH = ROWS * CELL;
  const OX = (W - GW) / 2, OY = 10;

  // Fixed path through the grid (an S-shape)
  const PATH_CELLS = [];
  // Build a winding path
  (function buildPath() {
    // Row 1, go right
    for (let c = 0; c < COLS - 2; c++) PATH_CELLS.push({ r: 1, c: c });
    // Go down
    for (let r = 1; r <= 3; r++) PATH_CELLS.push({ r: r, c: COLS - 3 });
    // Go left
    for (let c = COLS - 3; c >= 2; c--) PATH_CELLS.push({ r: 3, c: c });
    // Go down
    for (let r = 3; r <= 5; r++) PATH_CELLS.push({ r: r, c: 2 });
    // Go right
    for (let c = 2; c < COLS - 2; c++) PATH_CELLS.push({ r: 5, c: c });
    // Go down
    for (let r = 5; r <= 7; r++) PATH_CELLS.push({ r: r, c: COLS - 3 });
    // Go left
    for (let c = COLS - 3; c >= 2; c--) PATH_CELLS.push({ r: 7, c: c });
    // Go down
    for (let r = 7; r <= 9; r++) PATH_CELLS.push({ r: r, c: 2 });
    // Go right to exit
    for (let c = 2; c < COLS; c++) PATH_CELLS.push({ r: 9, c: c });
  })();

  // Convert path cells to pixel waypoints
  const PATH = PATH_CELLS.map(p => ({
    x: OX + p.c * CELL + CELL / 2,
    y: OY + p.r * CELL + CELL / 2
  }));

  const pathSet = new Set(PATH_CELLS.map(p => p.r + ',' + p.c));

  const TOWER_TYPES = {
    basic:  { name: 'Basic',  cost: 100, color: '#3b82f6', range: CELL * 2.5, damage: 15, fireRate: 800, splash: 0 },
    sniper: { name: 'Sniper', cost: 200, color: '#a855f7', range: CELL * 4.5, damage: 50, fireRate: 1500, splash: 0 },
    splash: { name: 'Splash', cost: 150, color: '#f97316', range: CELL * 2,   damage: 10, fireRate: 1000, splash: CELL * 1.5 }
  };

  const ENEMY_DEFS = {
    basic: { color: '#ef4444', radius: 5, speed: 1.2, maxHP: 80, bounty: 15 },
    fast:  { color: '#eab308', radius: 4, speed: 2.5, maxHP: 40, bounty: 10 },
    tank:  { color: '#22c55e', radius: 7, speed: 0.6, maxHP: 200, bounty: 30 },
    boss:  { color: '#f43f5e', radius: 10, speed: 0.4, maxHP: 500, bounty: 100 }
  };

  const WAVES = [
    [{ type: 'basic', count: 8, interval: 40 }],
    [{ type: 'basic', count: 10, interval: 35 }, { type: 'fast', count: 3, interval: 25, delay: 200 }],
    [{ type: 'fast', count: 8, interval: 20 }],
    [{ type: 'tank', count: 4, interval: 60 }, { type: 'basic', count: 10, interval: 30, delay: 100 }],
    [{ type: 'basic', count: 15, interval: 20 }, { type: 'tank', count: 3, interval: 50, delay: 150 }, { type: 'boss', count: 1, interval: 0, delay: 350 }]
  ];

  let towers = [];
  let enemies = [];
  let projectiles = [];
  let gold, lives, waveIndex, waveActive, spawners, selectedType, gameState;
  let frameCount = 0;

  function init() {
    towers = [];
    enemies = [];
    projectiles = [];
    gold = 300;
    lives = 20;
    waveIndex = 0;
    waveActive = false;
    spawners = [];
    selectedType = 'basic';
    gameState = 'building'; // building | waving | won | lost
    frameCount = 0;
    updateInfo();
  }

  function updateInfo() {
    const waveDisp = waveActive ? (waveIndex + 1) : waveIndex;
    infoEl.textContent = 'Gold: ' + gold + ' | Lives: ' + lives + ' | Wave: ' + waveDisp + '/5';
  }

  function isOnPath(r, c) { return pathSet.has(r + ',' + c); }
  function hasTower(r, c) { return towers.some(t => t.r === r && t.c === c); }

  function placeTower(r, c) {
    if (gameState === 'won' || gameState === 'lost') return;
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
    if (isOnPath(r, c) || hasTower(r, c)) return;
    const tt = TOWER_TYPES[selectedType];
    if (gold < tt.cost) return;
    gold -= tt.cost;
    towers.push({
      r, c,
      x: OX + c * CELL + CELL / 2,
      y: OY + r * CELL + CELL / 2,
      type: tt,
      lastShot: 0
    });
    updateInfo();
  }

  function startWave() {
    if (waveActive || gameState === 'won' || gameState === 'lost') return;
    if (waveIndex >= WAVES.length) return;
    waveActive = true;
    gameState = 'waving';
    const wave = WAVES[waveIndex];
    spawners = [];
    for (const group of wave) {
      spawners.push({
        type: group.type,
        count: group.count,
        interval: group.interval,
        delay: group.delay || 0,
        timer: 0,
        spawned: 0,
        delayDone: false
      });
    }
    updateInfo();
  }

  function distPx(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

  function update() {
    frameCount++;

    // Spawn enemies
    if (waveActive) {
      let allDone = true;
      for (const sp of spawners) {
        if (sp.spawned >= sp.count) continue;
        allDone = false;
        if (!sp.delayDone) {
          sp.delay--;
          if (sp.delay <= 0) sp.delayDone = true;
          continue;
        }
        sp.timer--;
        if (sp.timer <= 0) {
          const def = ENEMY_DEFS[sp.type];
          enemies.push({
            pathIndex: 0,
            x: PATH[0].x, y: PATH[0].y,
            def, hp: def.maxHP,
            alive: true
          });
          sp.spawned++;
          sp.timer = sp.interval;
        }
      }
      // Check if wave is complete (all spawned and all dead or gone)
      if (allDone && enemies.every(e => !e.alive)) {
        waveActive = false;
        waveIndex++;
        if (waveIndex >= WAVES.length) {
          gameState = 'won';
        } else {
          gameState = 'building';
        }
        updateInfo();
      }
    }

    // Move enemies
    for (const e of enemies) {
      if (!e.alive) continue;
      e.pathIndex += e.def.speed;
      const idx = Math.floor(e.pathIndex);
      if (idx >= PATH.length - 1) {
        e.alive = false;
        lives--;
        if (lives <= 0) {
          gameState = 'lost';
          waveActive = false;
        }
        updateInfo();
        continue;
      }
      const cur = PATH[Math.max(0, idx)];
      const next = PATH[Math.min(PATH.length - 1, idx + 1)];
      const frac = e.pathIndex - idx;
      e.x = cur.x + (next.x - cur.x) * frac;
      e.y = cur.y + (next.y - cur.y) * frac;
    }

    // Tower shooting
    for (const tw of towers) {
      if (frameCount - tw.lastShot < Math.floor(tw.type.fireRate / 16.67)) continue;
      // Find target (nearest)
      const inRange = enemies.filter(e => e.alive && distPx(tw, e) <= tw.type.range);
      if (inRange.length === 0) continue;
      const target = inRange.sort((a, b) => distPx(tw, a) - distPx(tw, b))[0];
      projectiles.push({
        x: tw.x, y: tw.y,
        target: target,
        damage: tw.type.damage,
        splash: tw.type.splash,
        speed: 4,
        active: true,
        color: tw.type.color
      });
      tw.lastShot = frameCount;
    }

    // Move projectiles
    for (const p of projectiles) {
      if (!p.active) continue;
      if (!p.target || !p.target.alive) { p.active = false; continue; }
      const dx = p.target.x - p.x, dy = p.target.y - p.y;
      const d = Math.hypot(dx, dy);
      if (d < 6) {
        // Hit
        if (p.splash > 0) {
          // Splash damage
          for (const e of enemies) {
            if (e.alive && distPx(p, e) <= p.splash) {
              e.hp -= p.damage;
              if (e.hp <= 0) { e.alive = false; gold += e.def.bounty; updateInfo(); }
            }
          }
        } else {
          p.target.hp -= p.damage;
          if (p.target.hp <= 0) { p.target.alive = false; gold += p.target.def.bounty; updateInfo(); }
        }
        p.active = false;
      } else {
        p.x += (dx / d) * p.speed;
        p.y += (dy / d) * p.speed;
      }
    }
    projectiles = projectiles.filter(p => p.active);
  }

  function render() {
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#0f0f1a';
    ctx.fillRect(0, 0, W, H);

    // Grid
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const x = OX + c * CELL, y = OY + r * CELL;
        if (isOnPath(r, c)) {
          ctx.fillStyle = '#1e293b';
        } else {
          ctx.fillStyle = '#111827';
        }
        ctx.fillRect(x + 0.5, y + 0.5, CELL - 1, CELL - 1);
      }
    }

    // Grid lines
    ctx.strokeStyle = '#1f2937';
    ctx.lineWidth = 0.5;
    for (let r = 0; r <= ROWS; r++) {
      ctx.beginPath(); ctx.moveTo(OX, OY + r * CELL); ctx.lineTo(OX + GW, OY + r * CELL); ctx.stroke();
    }
    for (let c = 0; c <= COLS; c++) {
      ctx.beginPath(); ctx.moveTo(OX + c * CELL, OY); ctx.lineTo(OX + c * CELL, OY + GH); ctx.stroke();
    }

    // Start / end markers
    const startCell = PATH_CELLS[0];
    const endCell = PATH_CELLS[PATH_CELLS.length - 1];
    ctx.fillStyle = '#22c55e';
    ctx.fillRect(OX + startCell.c * CELL + 2, OY + startCell.r * CELL + 2, CELL - 4, CELL - 4);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(OX + endCell.c * CELL + 2, OY + endCell.r * CELL + 2, CELL - 4, CELL - 4);

    // Towers
    for (const tw of towers) {
      // Range circle (faint)
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(tw.x, tw.y, tw.type.range, 0, Math.PI * 2);
      ctx.stroke();

      // Tower body
      ctx.fillStyle = tw.type.color;
      const s = CELL * 0.7;
      ctx.fillRect(tw.x - s / 2, tw.y - s / 2, s, s);
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(tw.x - s / 2, tw.y - s / 2, s, s);
    }

    // Enemies
    for (const e of enemies) {
      if (!e.alive) continue;
      ctx.fillStyle = e.def.color;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.def.radius, 0, Math.PI * 2);
      ctx.fill();

      // HP bar
      const barW = e.def.radius * 2.5;
      const hpPct = e.hp / e.def.maxHP;
      ctx.fillStyle = '#0f0f1a';
      ctx.fillRect(e.x - barW / 2, e.y - e.def.radius - 7, barW, 3);
      ctx.fillStyle = hpPct > 0.5 ? '#22c55e' : hpPct > 0.25 ? '#eab308' : '#ef4444';
      ctx.fillRect(e.x - barW / 2, e.y - e.def.radius - 7, barW * hpPct, 3);
    }

    // Projectiles
    for (const p of projectiles) {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    // HUD at bottom
    const hudY = OY + GH + 8;
    ctx.fillStyle = '#94a3b8';
    ctx.font = '11px "Inter", sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Selected: ' + TOWER_TYPES[selectedType].name +
      ' (Range: ' + Math.round(TOWER_TYPES[selectedType].range) +
      ', Dmg: ' + TOWER_TYPES[selectedType].damage + ')', OX, hudY + 14);

    // Game over / victory overlay
    if (gameState === 'won') {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(OX, OY + GH / 2 - 25, GW, 50);
      ctx.fillStyle = '#22c55e';
      ctx.font = 'bold 22px "Inter", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('VICTORY! All waves defeated!', OX + GW / 2, OY + GH / 2 + 7);
    } else if (gameState === 'lost') {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(OX, OY + GH / 2 - 25, GW, 50);
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 22px "Inter", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER -- Lives depleted', OX + GW / 2, OY + GH / 2 + 7);
    }
  }

  canvas.addEventListener('click', (e) => {
    if (gameState === 'won' || gameState === 'lost') { init(); return; }
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;
    const c = Math.floor((mx - OX) / CELL);
    const r = Math.floor((my - OY) / CELL);
    placeTower(r, c);
  });

  basicBtn.addEventListener('click', () => { selectedType = 'basic'; });
  sniperBtn.addEventListener('click', () => { selectedType = 'sniper'; });
  splashBtn.addEventListener('click', () => { selectedType = 'splash'; });
  startBtn.addEventListener('click', startWave);

  init();

  function loop() {
    update();
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
